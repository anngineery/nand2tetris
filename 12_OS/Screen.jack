/**
 * A library of functions for displaying graphics on the screen.
 * The Hack physical screen consists of 256 rows (indexed 0..255, top to bottom)
 * of 512 pixels each (indexed 0..511, left to right). The top left pixel on 
 * the screen is indexed (0,0).
 */
class Screen {
    static Array twoToThe;     
    static boolean colorIsBlack;
    static int screenBaseAddress;
    static int screenLastAddress;

    function void init() {
        var int j;
        
        let j = 1;
        let twoToThe[0] = 1;
        let screenBaseAddress = 16384;
        let screenLastAddress = 24575;

        while (j < 16){
            let twoToThe[j] = 2 * twoToThe[j-1];
            let j = j + 1;
        }
    }

    function void clearScreen(){
        var int j;
        let j = screenBaseAddress;

        while (j <= screenLastAddress){
            do Memory.poke(j, 0);
            let j = j + 1;
        }
    }

    /** Sets the current color, to be used for all subsequent drawXXX commands.
     *  Black is represented by true, white by false. */
    function void setColor(boolean b){
        let colorIsBlack = b;
    }

    function void drawPixel(int x, int y){
        // 512 / 16bits = 32 --> 1 row is broken into 32 addresses
        var int xDividedBy16, xMod16, address, value;

        let xDividedBy16 = x / 16;
        let address = 32 * y + xDividedBy16;
        let xMod16 = x - 16 * xDividedBy16;
        // we can't just change that bit, but change the whole word        
        let value = Memory.peek[screenBaseAddress + address];   

        if (isColorBlack){
            let value = value | twoToThe[xMod16];
        }
        else{
            let value = value & (~twoToThe[xMod16]);
        }

        do Memory.poke(address, value);
    }

    function void drawLine(int x1, int y1, int x2, int y2){
        // NOTE: performance improvement that can be made:
        // for vertical and horizontal lines, don't draw one pixel at a time
        // but do it all at once per address chunk
        var int startX, endX, startY, endY;
        var int incrementX, incrementY;

        let incrementX = 0;
        let incrementY = 0;

        // the line is horizontal line
        if (y1 == y2){
            let startX = min(x1, x2); 
            let endX = max(x1, x2);
            while (startX + incrementX <= endX){
                do drawPixel(startX + incrementX, y1);
                let incrementX = incrementX + 1;
            } 
    
            Return;
        }

        // the line is vertical line
        if (x1 == x2){
            let startY = min(y1, y2); 
            let end = max(y1, y2);
            while (startY + incrementY <= end){
                do drawPixel(x1, startY + incrementY);
                let incrementY = incrementY + 1;
            } 

            Return;
        }

        // diagonal line
        // always draw it in south-east direction, bc that is 
        // the direction both x and y increase. 
        let startX = min(x1, x2);
        let endX = max(x1, x2);
        let startY = max(y1, y2);
        let endY = min(y1, y2);
        let idealAngle = (endY - startY)/(endX - startX);

        while ((startX + incrementX <= endX) & (startY + incrementY <= endY)){
            let currAngle = incrementY / incrementX;
            
            if (currAngle > idealAngle){
                let incrementX = incrementX + 1;
            }
            else{
                let incrementY = incrementY + 1;            
            }
        }

    function void drawRectangle(int x1, int y1, int x2, int y2){
        do drawLine(x1, y1, x2, y1);
        do drawLine(x1, y2, x2, y2);
        do drawLine(x1, y1, x1, y2);
        do drawLine(x2, y1, x2, y2); 
    }

    function void drawCircle(int x, int y, int r){
        var int j;
        var int rSquared;
        var int diagonalDistance;

        let j = 0;
        let rSquared = r * r;

        while (j <= r){
            let jSquared = j * j; 
            let diagonalDistance = sqrt(rSquared - jSquared);
            do drawPixel(x - diagonalDistance, y - j);
            do drawPixel(x + diagonalDistance, y - j);
            do drawPixel(x - diagonalDistance, y + j);
            do drawPixel(x + diagonalDistance, y + j);
            let j = j + 1;
        } 
    }
}
